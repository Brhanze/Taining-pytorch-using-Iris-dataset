# -*- coding: utf-8 -*-
"""Iris data ste model traing with pytorch.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nviD-TLDGoiusnOlOyu3pL_iZbkO3ySS
"""

import torch
import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
  def __init__(self, in_features=4,h1=4,h2=4 ,out_fetures=4):
    super().__init__()
    self.fc1=nn.Linear(in_features,h1)
    self.fc2=nn.Linear(h1,h2)
    self.out=nn.Linear(h2,out_fetures)
  def forward(self,x):
    x=F.relu(self.fc1(x))
    x=F.relu(self.fc2(x))
    x=F.relu(self.out(x))
    return x
  torch.manual_seed(22)
model=Model()

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import matplotlib.pyplot as plt

# %matplotlib inline

url='https://gist.githubusercontent.com/Thanatoz-1/9e7fdfb8189f0cdf5d73a494e4a6392a/raw/aaecbd14aeaa468cd749528f291aa8a30c2ea09e/iris_dataset.csv'
df=pd.read_csv(url)
df.head()

df['target'].unique()

df['target']=df['target'].map({'Iris-setosa':0,'Iris-versicolor':1,'Iris-virginica':2})
df.tail()

"""## train and split the data sets"""

x=df.drop('target',axis=1)
y=df['target']
x.head()

y.tail()

"""## change X and Y to arrays"""

x=x.values
y=y.values
x

y

"""## Train test split"""

from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.2,random_state=42)
x_train=torch.FloatTensor(x_train)
x_test=torch.FloatTensor(x_test)
y_train=torch.LongTensor(y_train)
y_test=torch.LongTensor(y_test)

criterion=nn.CrossEntropyLoss()
optimizer=torch.optim.Adam(model.parameters(),lr=0.01)
model.parameters

epochs=100
losses=[]
for i in range(epochs):
  y_pred=model.forward(x_train)
  loss=criterion(y_pred,y_train)
  losses.append(loss.detach().numpy())
  print(f'epoch:{i} and loss:{loss}')
  optimizer.zero_grad()
  loss.backward()
  optimizer.step()

plt.plot(range(epochs),losses)
plt.ylabel('loss/error')
plt.xlabel('epochs')
plt.show()

with torch.no_grad():
  y_eval=model.forward(x_test)
  loss=criterion(y_eval,y_test)
  print(loss)

correct=0
with torch.no_grad():
  for i,data in enumerate(x_test):

    y_eval=model.forward(data)
    print(f'{i+1}.) {str(y_eval)}\t {y_test[i]}\t {y_eval.argmax().item()}')
    if y_eval.argmax().item()==y_test[i]:
     correct+=1

  print(f'we goat:{correct}')

"""## test nn model"""

new_iris=torch.tensor([4.7,3.2,1.3,0.2])
with torch.no_grad():
  print(model(new_iris))

newer_iris=torch.tensor([5.9,3.0,5.1,1.1])
with torch.no_grad():
  print(model(newer_iris))

"""## save the model"""

torch.save(model.state_dict(),'Iris_pytoch.pt')

"""## load the model"""

new_model=Model()
new_model.load_state_dict(torch.load('Iris_pytoch.pt'))

new_model.eval()